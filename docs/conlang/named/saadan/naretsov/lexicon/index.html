<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Lexicon</title>
    <style>
        #content {
            margin-left: 235px;
            padding-top: 10px
        }

        #sidebar {
            position: fixed;
            top: 0;
            left: 0;
            background: #eee;
            width: 180px;
            height: 100%;
            z-index: 5;
            border-right: 5px solid #888;
            padding-left: 10px
        }

        #title {
            padding: 10px 0;
            margin: 0
        }

        #search {
            width: 160px
        }

        #scon {
            margin: 0;
            padding: 0
        }

        html,
        body {
            width: 100%;
            height: 100%;
            margin: 0;
            background: #fafafa;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 15px;
            line-height: 1.5;
            color: #555;
            padding: 0
        }

        a {
            color: #4183C4;
            text-decoration: none
        }

        blockquote {
            border-left: 4px solid #dddddd;
            padding: 0 15px;
            color: #777
        }

        code,
        tt {
            margin: 0 2px;
            padding: 0 5px;
            white-space: nowrap;
            border: 1px solid #eaeaea;
            color: #000;
            background-color: #fefefe;
            border-radius: 3px
        }

        pre code {
            margin: 0;
            padding: 0;
            white-space: pre;
            border: none;
            background: transparent
        }

        pre {
            background: #fefefe;
            border: 1px solid #cccccc;
            font-size: 13px;
            line-height: 19px;
            overflow: auto;
            overflow-y: hidden;
            width: 97%;
            padding: 6px 10px;
            border-radius: 3px
        }

        pre code,
        pre tt {
            background: transparent;
            border: none
        }

        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            margin: 2px 0
        }

        p,
        ul,
        ol {
            margin: 4px 0
        }

        #nav {
            width: 240px;
            position: fixed;
            padding: 5px 20px 30px 0;
            top: 0;
            left: 0;
            font-size: 85%;
            background: #eee;
            z-index: 5;
            height: 100%;
            margin-left: -260px;
            border-right: 20px solid #888;
            transition: all 0.4s ease;
            overflow-y: scroll;
        }

        #nav span {
            display: block;
            padding-left: 10px;
            margin: 0;
        }

        #nav:hover {
            margin-left: 0;
            padding: 0 20px;
            border-right-width: 0
        }

        #tocm {
            padding: 3px 6px;
            position: fixed;
            top: 0;
            left: 0;
            background: #000;
            color: #fff;
            z-index: 20;
            transition: all 0.4s ease;
            display: block;
        }

        #nav:hover #tocm {
            margin-top: -30px;
        }
    </style>
    <script>
        /**
           * marked - a markdown parser
           * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
           * https://github.com/chjj/marked
           */
        (function () { function e(e) { this.tokens = [], this.tokens.links = {}, this.options = e || a.defaults, this.rules = p.normal, this.options.gfm && (this.rules = this.options.tables ? p.tables : p.gfm) } function t(e, t) { if (this.options = t || a.defaults, this.links = e, this.rules = u.normal, this.renderer = this.options.renderer || new n, this.renderer.options = this.options, !this.links) throw new Error("Tokens array requires a `links` property."); this.options.gfm ? this.rules = this.options.breaks ? u.breaks : u.gfm : this.options.pedantic && (this.rules = u.pedantic) } function n(e) { this.options = e || {} } function r(e) { this.tokens = [], this.token = null, this.options = e || a.defaults, this.options.renderer = this.options.renderer || new n, this.renderer = this.options.renderer, this.renderer.options = this.options } function s(e, t) { return e.replace(t ? /&/g : /&(?!#?\w+;)/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;") } function i(e) { return e.replace(/&([#\w]+);/g, function (e, t) { return t = t.toLowerCase(), "colon" === t ? ":" : "#" === t.charAt(0) ? String.fromCharCode("x" === t.charAt(1) ? parseInt(t.substring(2), 16) : +t.substring(1)) : "" }) } function l(e, t) { return e = e.source, t = t || "", function n(r, s) { return r ? (s = s.source || s, s = s.replace(/(^|[^\[])\^/g, "$1"), e = e.replace(r, s), n) : new RegExp(e, t) } } function o() { } function h(e) { for (var t, n, r = 1; r < arguments.length; r++) { t = arguments[r]; for (n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]) } return e } function a(t, n, i) { if (i || "function" == typeof n) { i || (i = n, n = null), n = h({}, a.defaults, n || {}); var l, o, p = n.highlight, u = 0; try { l = e.lex(t, n) } catch (c) { return i(c) } o = l.length; var g = function (e) { if (e) return n.highlight = p, i(e); var t; try { t = r.parse(l, n) } catch (s) { e = s } return n.highlight = p, e ? i(e) : i(null, t) }; if (!p || p.length < 3) return g(); if (delete n.highlight, !o) return g(); for (; u < l.length; u++)!function (e) { return "code" !== e.type ? --o || g() : p(e.text, e.lang, function (t, n) { return t ? g(t) : null == n || n === e.text ? --o || g() : (e.text = n, e.escaped = !0, void (--o || g())) }) }(l[u]) } else try { return n && (n = h({}, a.defaults, n)), r.parse(e.lex(t, n), n) } catch (c) { if (c.message += "\nPlease report this to https://github.com/chjj/marked.", (n || a.defaults).silent) return "<p>An error occured:</p><pre>" + s(c.message + "", !0) + "</pre>"; throw c } } var p = { newline: /^\n+/, code: /^( {4}[^\n]+\n*)+/, fences: o, hr: /^( *[-*_]){3,} *(?:\n+|$)/, heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/, nptable: o, lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/, blockquote: /^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/, list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/, html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/, def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/, table: o, paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/, text: /^[^\n]+/ }; p.bullet = /(?:[*+-]|\d+\.)/, p.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/, p.item = l(p.item, "gm")(/bull/g, p.bullet)(), p.list = l(p.list)(/bull/g, p.bullet)("hr", "\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))")("def", "\\n+(?=" + p.def.source + ")")(), p.blockquote = l(p.blockquote)("def", p.def)(), p._tag = "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b", p.html = l(p.html)("comment", /<!--[\s\S]*?-->/)("closed", /<(tag)[\s\S]+?<\/\1>/)("closing", /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)(/tag/g, p._tag)(), p.paragraph = l(p.paragraph)("hr", p.hr)("heading", p.heading)("lheading", p.lheading)("blockquote", p.blockquote)("tag", "<" + p._tag)("def", p.def)(), p.normal = h({}, p), p.gfm = h({}, p.normal, { fences: /^ *(`{3,}|~{3,}) *(\S+)? *\n([\s\S]+?)\s*\1 *(?:\n+|$)/, paragraph: /^/ }), p.gfm.paragraph = l(p.paragraph)("(?!", "(?!" + p.gfm.fences.source.replace("\\1", "\\2") + "|" + p.list.source.replace("\\1", "\\3") + "|")(), p.tables = h({}, p.gfm, { nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/, table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/ }), e.rules = p, e.lex = function (t, n) { var r = new e(n); return r.lex(t) }, e.prototype.lex = function (e) { return e = e.replace(/\r\n|\r/g, "\n").replace(/\t/g, "    ").replace(/\u00a0/g, " ").replace(/\u2424/g, "\n"), this.token(e, !0) }, e.prototype.token = function (e, t, n) { for (var r, s, i, l, o, h, a, u, c, e = e.replace(/^ +$/gm, ""); e;)if ((i = this.rules.newline.exec(e)) && (e = e.substring(i[0].length), i[0].length > 1 && this.tokens.push({ type: "space" })), i = this.rules.code.exec(e)) e = e.substring(i[0].length), i = i[0].replace(/^ {4}/gm, ""), this.tokens.push({ type: "code", text: this.options.pedantic ? i : i.replace(/\n+$/, "") }); else if (i = this.rules.fences.exec(e)) e = e.substring(i[0].length), this.tokens.push({ type: "code", lang: i[2], text: i[3] }); else if (i = this.rules.heading.exec(e)) e = e.substring(i[0].length), this.tokens.push({ type: "heading", depth: i[1].length, text: i[2] }); else if (t && (i = this.rules.nptable.exec(e))) { for (e = e.substring(i[0].length), h = { type: "table", header: i[1].replace(/^ *| *\| *$/g, "").split(/ *\| */), align: i[2].replace(/^ *|\| *$/g, "").split(/ *\| */), cells: i[3].replace(/\n$/, "").split("\n") }, u = 0; u < h.align.length; u++)h.align[u] = /^ *-+: *$/.test(h.align[u]) ? "right" : /^ *:-+: *$/.test(h.align[u]) ? "center" : /^ *:-+ *$/.test(h.align[u]) ? "left" : null; for (u = 0; u < h.cells.length; u++)h.cells[u] = h.cells[u].split(/ *\| */); this.tokens.push(h) } else if (i = this.rules.lheading.exec(e)) e = e.substring(i[0].length), this.tokens.push({ type: "heading", depth: "=" === i[2] ? 1 : 2, text: i[1] }); else if (i = this.rules.hr.exec(e)) e = e.substring(i[0].length), this.tokens.push({ type: "hr" }); else if (i = this.rules.blockquote.exec(e)) e = e.substring(i[0].length), this.tokens.push({ type: "blockquote_start" }), i = i[0].replace(/^ *> ?/gm, ""), this.token(i, t, !0), this.tokens.push({ type: "blockquote_end" }); else if (i = this.rules.list.exec(e)) { for (e = e.substring(i[0].length), l = i[2], this.tokens.push({ type: "list_start", ordered: l.length > 1 }), i = i[0].match(this.rules.item), r = !1, c = i.length, u = 0; c > u; u++)h = i[u], a = h.length, h = h.replace(/^ *([*+-]|\d+\.) +/, ""), ~h.indexOf("\n ") && (a -= h.length, h = this.options.pedantic ? h.replace(/^ {1,4}/gm, "") : h.replace(new RegExp("^ {1," + a + "}", "gm"), "")), this.options.smartLists && u !== c - 1 && (o = p.bullet.exec(i[u + 1])[0], l === o || l.length > 1 && o.length > 1 || (e = i.slice(u + 1).join("\n") + e, u = c - 1)), s = r || /\n\n(?!\s*$)/.test(h), u !== c - 1 && (r = "\n" === h.charAt(h.length - 1), s || (s = r)), this.tokens.push({ type: s ? "loose_item_start" : "list_item_start" }), this.token(h, !1, n), this.tokens.push({ type: "list_item_end" }); this.tokens.push({ type: "list_end" }) } else if (i = this.rules.html.exec(e)) e = e.substring(i[0].length), this.tokens.push({ type: this.options.sanitize ? "paragraph" : "html", pre: "pre" === i[1] || "script" === i[1] || "style" === i[1], text: i[0] }); else if (!n && t && (i = this.rules.def.exec(e))) e = e.substring(i[0].length), this.tokens.links[i[1].toLowerCase()] = { href: i[2], title: i[3] }; else if (t && (i = this.rules.table.exec(e))) { for (e = e.substring(i[0].length), h = { type: "table", header: i[1].replace(/^ *| *\| *$/g, "").split(/ *\| */), align: i[2].replace(/^ *|\| *$/g, "").split(/ *\| */), cells: i[3].replace(/(?: *\| *)?\n$/, "").split("\n") }, u = 0; u < h.align.length; u++)h.align[u] = /^ *-+: *$/.test(h.align[u]) ? "right" : /^ *:-+: *$/.test(h.align[u]) ? "center" : /^ *:-+ *$/.test(h.align[u]) ? "left" : null; for (u = 0; u < h.cells.length; u++)h.cells[u] = h.cells[u].replace(/^ *\| *| *\| *$/g, "").split(/ *\| */); this.tokens.push(h) } else if (t && (i = this.rules.paragraph.exec(e))) e = e.substring(i[0].length), this.tokens.push({ type: "paragraph", text: "\n" === i[1].charAt(i[1].length - 1) ? i[1].slice(0, -1) : i[1] }); else if (i = this.rules.text.exec(e)) e = e.substring(i[0].length), this.tokens.push({ type: "text", text: i[0] }); else if (e) throw new Error("Infinite loop on byte: " + e.charCodeAt(0)); return this.tokens }; var u = { escape: /^\\([\\`*{}\[\]()#+\-.!_>])/, autolink: /^<([^ >]+(@|:\/)[^ >]+)>/, url: o, tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/, link: /^!?\[(inside)\]\(href\)/, reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/, nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/, strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/, em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/, br: /^ {2,}\n(?!\s*$)/, del: o, text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/ }; u._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/, u._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/, u.link = l(u.link)("inside", u._inside)("href", u._href)(), u.reflink = l(u.reflink)("inside", u._inside)(), u.normal = h({}, u), u.pedantic = h({}, u.normal, { strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/, em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/ }), u.gfm = h({}, u.normal, { escape: l(u.escape)("])", "~|])")(), url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/, del: /^~~(?=\S)([\s\S]*?\S)~~/, text: l(u.text)("]|", "~]|")("|", "|https?://|")() }), u.breaks = h({}, u.gfm, { br: l(u.br)("{2,}", "*")(), text: l(u.gfm.text)("{2,}", "*")() }), t.rules = u, t.output = function (e, n, r) { var s = new t(n, r); return s.output(e) }, t.prototype.output = function (e) { for (var t, n, r, i, l = ""; e;)if (i = this.rules.escape.exec(e)) e = e.substring(i[0].length), l += i[1]; else if (i = this.rules.autolink.exec(e)) e = e.substring(i[0].length), "@" === i[2] ? (n = this.mangle(":" === i[1].charAt(6) ? i[1].substring(7) : i[1]), r = this.mangle("mailto:") + n) : (n = s(i[1]), r = n), l += this.renderer.link(r, null, n); else if (this.inLink || !(i = this.rules.url.exec(e))) { if (i = this.rules.tag.exec(e)) !this.inLink && /^<a /i.test(i[0]) ? this.inLink = !0 : this.inLink && /^<\/a>/i.test(i[0]) && (this.inLink = !1), e = e.substring(i[0].length), l += this.options.sanitize ? s(i[0]) : i[0]; else if (i = this.rules.link.exec(e)) e = e.substring(i[0].length), this.inLink = !0, l += this.outputLink(i, { href: i[2], title: i[3] }), this.inLink = !1; else if ((i = this.rules.reflink.exec(e)) || (i = this.rules.nolink.exec(e))) { if (e = e.substring(i[0].length), t = (i[2] || i[1]).replace(/\s+/g, " "), t = this.links[t.toLowerCase()], !t || !t.href) { l += i[0].charAt(0), e = i[0].substring(1) + e; continue } this.inLink = !0, l += this.outputLink(i, t), this.inLink = !1 } else if (i = this.rules.strong.exec(e)) e = e.substring(i[0].length), l += this.renderer.strong(this.output(i[2] || i[1])); else if (i = this.rules.em.exec(e)) e = e.substring(i[0].length), l += this.renderer.em(this.output(i[2] || i[1])); else if (i = this.rules.code.exec(e)) e = e.substring(i[0].length), l += this.renderer.codespan(s(i[2], !0)); else if (i = this.rules.br.exec(e)) e = e.substring(i[0].length), l += this.renderer.br(); else if (i = this.rules.del.exec(e)) e = e.substring(i[0].length), l += this.renderer.del(this.output(i[1])); else if (i = this.rules.text.exec(e)) e = e.substring(i[0].length), l += s(this.smartypants(i[0])); else if (e) throw new Error("Infinite loop on byte: " + e.charCodeAt(0)) } else e = e.substring(i[0].length), n = s(i[1]), r = n, l += this.renderer.link(r, null, n); return l }, t.prototype.outputLink = function (e, t) { var n = s(t.href), r = t.title ? s(t.title) : null; return "!" !== e[0].charAt(0) ? this.renderer.link(n, r, this.output(e[1])) : this.renderer.image(n, r, s(e[1])) }, t.prototype.smartypants = function (e) { return this.options.smartypants ? e.replace(/--/g, "—").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1‘").replace(/'/g, "’").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1“").replace(/"/g, "”").replace(/\.{3}/g, "…") : e }, t.prototype.mangle = function (e) { for (var t, n = "", r = e.length, s = 0; r > s; s++)t = e.charCodeAt(s), Math.random() > .5 && (t = "x" + t.toString(16)), n += "&#" + t + ";"; return n }, n.prototype.code = function (e, t, n) { if (this.options.highlight) { var r = this.options.highlight(e, t); null != r && r !== e && (n = !0, e = r) } return t ? '<pre><code class="' + this.options.langPrefix + s(t, !0) + '">' + (n ? e : s(e, !0)) + "\n</code></pre>\n" : "<pre><code>" + (n ? e : s(e, !0)) + "\n</code></pre>" }, n.prototype.blockquote = function (e) { return "<blockquote>\n" + e + "</blockquote>\n" }, n.prototype.html = function (e) { return e }, n.prototype.heading = function (e, t, n) { return "<h" + t + ' id="' + this.options.headerPrefix + n.toLowerCase().replace(/[^\w]+/g, "-") + '">' + e + "</h" + t + ">\n" }, n.prototype.hr = function () { return this.options.xhtml ? "<hr/>\n" : "<hr>\n" }, n.prototype.list = function (e, t) { var n = t ? "ol" : "ul"; return "<" + n + ">\n" + e + "</" + n + ">\n" }, n.prototype.listitem = function (e) { return "<li>" + e + "</li>\n" }, n.prototype.paragraph = function (e) { return "<p>" + e + "</p>\n" }, n.prototype.table = function (e, t) { return "<table>\n<thead>\n" + e + "</thead>\n<tbody>\n" + t + "</tbody>\n</table>\n" }, n.prototype.tablerow = function (e) { return "<tr>\n" + e + "</tr>\n" }, n.prototype.tablecell = function (e, t) { var n = t.header ? "th" : "td", r = t.align ? "<" + n + ' style="text-align:' + t.align + '">' : "<" + n + ">"; return r + e + "</" + n + ">\n" }, n.prototype.strong = function (e) { return "<strong>" + e + "</strong>" }, n.prototype.em = function (e) { return "<em>" + e + "</em>" }, n.prototype.codespan = function (e) { return "<code>" + e + "</code>" }, n.prototype.br = function () { return this.options.xhtml ? "<br/>" : "<br>" }, n.prototype.del = function (e) { return "<del>" + e + "</del>" }, n.prototype.link = function (e, t, n) { if (this.options.sanitize) { try { var r = decodeURIComponent(i(e)).replace(/[^\w:]/g, "").toLowerCase() } catch (s) { return "" } if (0 === r.indexOf("javascript:") || 0 === r.indexOf("vbscript:")) return "" } var l = '<a href="' + e + '"'; return t && (l += ' title="' + t + '"'), l += ">" + n + "</a>" }, n.prototype.image = function (e, t, n) { var r = '<img src="' + e + '" alt="' + n + '"'; return t && (r += ' title="' + t + '"'), r += this.options.xhtml ? "/>" : ">" }, r.parse = function (e, t, n) { var s = new r(t, n); return s.parse(e) }, r.prototype.parse = function (e) { this.inline = new t(e.links, this.options, this.renderer), this.tokens = e.reverse(); for (var n = ""; this.next();)n += this.tok(); return n }, r.prototype.next = function () { return this.token = this.tokens.pop() }, r.prototype.peek = function () { return this.tokens[this.tokens.length - 1] || 0 }, r.prototype.parseText = function () { for (var e = this.token.text; "text" === this.peek().type;)e += "\n" + this.next().text; return this.inline.output(e) }, r.prototype.tok = function () { switch (this.token.type) { case "space": return ""; case "hr": return this.renderer.hr(); case "heading": return this.renderer.heading(this.inline.output(this.token.text), this.token.depth, this.token.text); case "code": return this.renderer.code(this.token.text, this.token.lang, this.token.escaped); case "table": var e, t, n, r, s, i = "", l = ""; for (n = "", e = 0; e < this.token.header.length; e++)r = { header: !0, align: this.token.align[e] }, n += this.renderer.tablecell(this.inline.output(this.token.header[e]), { header: !0, align: this.token.align[e] }); for (i += this.renderer.tablerow(n), e = 0; e < this.token.cells.length; e++) { for (t = this.token.cells[e], n = "", s = 0; s < t.length; s++)n += this.renderer.tablecell(this.inline.output(t[s]), { header: !1, align: this.token.align[s] }); l += this.renderer.tablerow(n) } return this.renderer.table(i, l); case "blockquote_start": for (var l = ""; "blockquote_end" !== this.next().type;)l += this.tok(); return this.renderer.blockquote(l); case "list_start": for (var l = "", o = this.token.ordered; "list_end" !== this.next().type;)l += this.tok(); return this.renderer.list(l, o); case "list_item_start": for (var l = ""; "list_item_end" !== this.next().type;)l += "text" === this.token.type ? this.parseText() : this.tok(); return this.renderer.listitem(l); case "loose_item_start": for (var l = ""; "list_item_end" !== this.next().type;)l += this.tok(); return this.renderer.listitem(l); case "html": var h = this.token.pre || this.options.pedantic ? this.token.text : this.inline.output(this.token.text); return this.renderer.html(h); case "paragraph": return this.renderer.paragraph(this.inline.output(this.token.text)); case "text": return this.renderer.paragraph(this.parseText()) } }, o.exec = o, a.options = a.setOptions = function (e) { return h(a.defaults, e), a }, a.defaults = { gfm: !0, tables: !0, breaks: !1, pedantic: !1, sanitize: !1, smartLists: !1, silent: !1, highlight: null, langPrefix: "lang-", smartypants: !1, headerPrefix: "", renderer: new n, xhtml: !1 }, a.Parser = r, a.parser = r.parse, a.Renderer = n, a.Lexer = e, a.lexer = e.lex, a.InlineLexer = t, a.inlineLexer = t.output, a.parse = a, "undefined" != typeof module && "object" == typeof exports ? module.exports = a : "function" == typeof define && define.amd ? define(function () { return a }) : this.marked = a }).call(function () { return this || ("undefined" != typeof window ? window : global) }());

        /** https://glench.github.io/fuzzyset.js/ */ !function () { var t = function (t, r, e, n) { var i = { version: "0.0.1" }; t = t || [], i.gramSizeLower = e || 2, i.gramSizeUpper = n || 3, i.useLevenshtein = "boolean" != typeof r ? !0 : r, i.exactSet = {}, i.matchDict = {}, i.items = {}; var a = function (t, r) { for (var e, n, i = [], a = 0; a <= r.length; a++)for (var h = 0; h <= t.length; h++)n = a && h ? t.charAt(h - 1) === r.charAt(a - 1) ? e : Math.min(i[h], i[h - 1], e) + 1 : a + h, e = i[h], i[h] = n; return i.pop() }, h = function (t, r) { if (null === t && null === r) throw "Trying to compare two null values"; if (null === t || null === r) return 0; t = String(t), r = String(r); var e = a(t, r); return t.length > r.length ? 1 - e / t.length : 1 - e / r.length }, o = /[^\w, ]+/, s = function (t, r) { r = r || 2; var e = "-" + t.toLowerCase().replace(o, "") + "-", n = r - e.length, i = []; if (n > 0) for (var a = 0; n > a; ++a)t += "-"; for (var a = 0; a < e.length - r + 1; ++a)i.push(e.slice(a, a + r)); return i }, u = function (t, r) { r = r || 2; var e = {}, n = s(t, r), i = 0; for (i; i < n.length; ++i)n[i] in e ? e[n[i]] += 1 : e[n[i]] = 1; return e }; i.get = function (t, r) { var e = this._get(t); return !e && r ? r : e }, i._get = function (t) { var r = this._normalizeStr(t), e = this.exactSet[r]; if (e) return [[1, e]]; for (var n = [], i = this.gramSizeUpper; i >= this.gramSizeLower; --i)if (n = this.__get(t, i)) return n; return null }, i.__get = function (t, r) { function e(t) { for (var r in t) if (t.hasOwnProperty(r)) return !1; return !0 } var n, i, a, o, s, c = this._normalizeStr(t), f = {}, l = u(c, r), g = this.items[r], m = 0; for (n in l) if (i = l[n], m += Math.pow(i, 2), n in this.matchDict) for (a = 0; a < this.matchDict[n].length; ++a)o = this.matchDict[n][a][0], s = this.matchDict[n][a][1], o in f ? f[o] += i * s : f[o] = i * s; if (e(f)) return null; var v, p = Math.sqrt(m), S = []; for (var z in f) v = f[z], S.push([v / (p * g[z][0]), g[z][1]]); var w = function (t, r) { return t[0] < r[0] ? 1 : t[0] > r[0] ? -1 : 0 }; if (S.sort(w), this.useLevenshtein) { for (var x = [], d = Math.min(50, S.length), a = 0; d > a; ++a)x.push([h(S[a][1], c), S[a][1]]); S = x, S.sort(w) } for (var x = [], a = 0; a < S.length; ++a)S[a][0] == S[0][0] && x.push([S[a][0], this.exactSet[S[a][1]]]); return x }, i.add = function (t) { var r = this._normalizeStr(t); if (r in this.exactSet) return !1; var e = this.gramSizeLower; for (e; e < this.gramSizeUpper + 1; ++e)this._add(t, e) }, i._add = function (t, r) { var e = this._normalizeStr(t), n = this.items[r] || [], i = n.length; n.push(0); var a, h, o = u(e, r), s = 0; for (a in o) h = o[a], s += Math.pow(h, 2), a in this.matchDict ? this.matchDict[a].push([i, h]) : this.matchDict[a] = [[i, h]]; var c = Math.sqrt(s); n[i] = [c, e], this.items[r] = n, this.exactSet[e] = t }, i._normalizeStr = function (t) { if ("[object String]" !== Object.prototype.toString.call(t)) throw "Must use a string as argument to FuzzySet functions"; return t.toLowerCase() }, i.length = function () { var t, r = 0; for (t in this.exactSet) this.exactSet.hasOwnProperty(t) && (r += 1); return r }, i.isEmpty = function () { for (var t in this.exactSet) if (this.exactSet.hasOwnProperty(t)) return !1; return !0 }, i.values = function () { var t, r = []; for (t in this.exactSet) this.exactSet.hasOwnProperty(t) && r.push(this.exactSet[t]); return r }; var c = i.gramSizeLower; for (c; c < i.gramSizeUpper + 1; ++c)i.items[c] = []; for (c = 0; c < t.length; ++c)i.add(t[c]); return i }, r = this; "undefined" != typeof module && module.exports ? (module.exports = t, r.FuzzySet = t) : r.FuzzySet = t }();

        /** https://stackoverflow.com/questions/610406/javascript-equivalent-to-printf-string-format/4673436#4673436 */
        if (!String.prototype.format) String.prototype.format = function () { var a = arguments; return this.replace(/{(\d+)}/g, function (m, n) { return (typeof a[n] != 'undefined') ? a[n] : m; }); };

        /**
         * MDN polyfill
         */
        if (!String.prototype.endsWith) String.prototype.endsWith = function (t, n) { var e = this.toString(); (void 0 === n || n > e.length) && (n = e.length), n -= t.length; var i = e.indexOf(t, n); return -1 !== i && i === n };

        //custom code below here==
        if (!String.prototype.mult) String.prototype.mult = function (times) { var o = this; for (; times > 1; times--)o += this; return o; }

        var data = {}, searchCache;

        function md(text) {
            return marked(text.replace(/\[\[([^\]]*)\]\]/g, function (m, t) {
                return "[{0}](#/{1}/{2})".format(htmlEnt(t), data.meta.lexicon, t);
            }));
        }
        var renderWord = (function () {
            var registry = {}, o = function (word) {
                var out = "", w = data.lexicon[word];
                for (var sect in w) {
                    var conf = merge(data.meta.defaults['*'], (sect in data.meta.defaults) ? data.meta.defaults[sect] : {});
                    out += "#".mult(conf.level) + " " + sect + "\n";
                    if (conf.type in registry)
                        out += registry[conf.type](w[sect], word, sect);
                    else {
                        if (typeof w[sect] === "string") w[sect] = [w[sect]];
                        for (var c = 0; c < w[sect].length; c++)
                            out += "{0}\n\n".format(w[sect][c]);
                    }
                    if (!out.endsWith("\n\n")) out += "\n";
                }
                return data.page.lexicon.format(htmlEnt(word), out);
            };
            o.register = function (_type, handler) { registry[_type] = handler; };
            return o;
        })();

        renderWord.register("definition", function (entry, word, sect) {
            var out = "";
            if (entry.hasOwnProperty("head")) {
                out += "__{0}__ ({1})  \n".format(htmlEnt(word), (function (h) {
                    if (typeof h === "string") return h;
                    var n = "";
                    for (var d in h) {
                        if (typeof h[d] === "string")
                            n += "*{0}* __[[{1}]]__, ".format(d, h[d]);
                        else {
                            n += "*{0}* __[[{1}]]__".format(d, h[d][0]);
                            for (var e = 1; e < h[d].length; e++)
                                n += " *or* __[[{0}]]__".format(h[d][e]);
                            n += ", ";
                        }
                    }
                    return n.substring(0, n.length - 2);
                })(entry.head));
                entry = entry.def;
            } else out += "__{0}__\n".format(word);
            if (typeof entry === "string") entry = [entry];
            for (var c in entry) out += "{0}. {1}\n".format(c + 1, entry[c]);
            return out;
        });
        renderWord.register("bullet-list", function (entry) {
            var out = "";
            if (typeof entry === "string") entry = [entry];
            for (var c in entry) out += "- {0}\n".format(entry[c]);
            return out;
        });
        renderWord.register("word-link-list", function (entry) {
            var out = "";
            if (typeof entry === "string") entry = [entry];
            for (var c in entry) out += "- [[{0}]]\n".format(entry[c]);
            return out;
        });

        function merge() { var e = {}; for (var r in arguments) if ("object" == typeof arguments[r]) for (var a in arguments[r]) if (a in e) if (Array.isArray(e[a]) && Array.isArray(arguments[r][a])) { var t = e[a].length; for (var n in arguments[r][a]) e[a][t + n] = arguments[r][a][n] } else e[a] = "object" == typeof e[a] && "object" == typeof arguments[r][a] ? merge(e[a], arguments[r][a]) : arguments[r][a]; else e[a] = arguments[r][a]; return e }

        function getKeys(obj) { var e = []; for (var k in obj) e.push(k); return e; }
        function htmlEnt(str) { return str.replace(/[&<>]/g, function (e) { if (e == "&") return "&amp;"; else if (e == "<") return "&lt;"; else return "&gt;"; }); }

        function lexicon(loc, useNav) {
            if (useNav) {
                document.getElementById("sidebar").setAttribute("id", "nav");
                document.getElementById("tocm").setAttribute("style", "");
                document.getElementById("content").setAttribute("style", "margin-left:60px");
            }
            document.getElementById("search").addEventListener("keydown", function (e) {
                if (!e) { var e = window.event; } if (e.keyCode == 13) {
                    location.hash = "#/" + data.meta.searchPath + "/" + document.getElementById("search").value;
                }
            }, false);
            if (!("onhashchange" in window)) {
                alert("This browser does not support vital functionality. Please update your browser to one that supports the hashchange event.");
            } else {
                console.log("[DEBUG] hashchange supported.");
                function show(str) { document.getElementById("content").innerHTML = md(str); }
                window.onhashchange = function () {
                    var path = decodeURIComponent(location.hash.substr(2)).split("/");
                    if (path.length == 0) {
                        if (data.page.main) show(data.page.main); else show('<img src="data:image/gif;base64,R0lGODlhEAAQAPIAAP///wAAAMLCwkJCQgAAAGJiYoKCgpKSkiH/C05FVFNDQVBFMi4wAwEAAAAh/hpDcmVhdGVkIHdpdGggYWpheGxvYWQuaW5mbwAh+QQJCgAAACwAAAAAEAAQAAADMwi63P4wyklrE2MIOggZnAdOmGYJRbExwroUmcG2LmDEwnHQLVsYOd2mBzkYDAdKa+dIAAAh+QQJCgAAACwAAAAAEAAQAAADNAi63P5OjCEgG4QMu7DmikRxQlFUYDEZIGBMRVsaqHwctXXf7WEYB4Ag1xjihkMZsiUkKhIAIfkECQoAAAAsAAAAABAAEAAAAzYIujIjK8pByJDMlFYvBoVjHA70GU7xSUJhmKtwHPAKzLO9HMaoKwJZ7Rf8AYPDDzKpZBqfvwQAIfkECQoAAAAsAAAAABAAEAAAAzMIumIlK8oyhpHsnFZfhYumCYUhDAQxRIdhHBGqRoKw0R8DYlJd8z0fMDgsGo/IpHI5TAAAIfkECQoAAAAsAAAAABAAEAAAAzIIunInK0rnZBTwGPNMgQwmdsNgXGJUlIWEuR5oWUIpz8pAEAMe6TwfwyYsGo/IpFKSAAAh+QQJCgAAACwAAAAAEAAQAAADMwi6IMKQORfjdOe82p4wGccc4CEuQradylesojEMBgsUc2G7sDX3lQGBMLAJibufbSlKAAAh+QQJCgAAACwAAAAAEAAQAAADMgi63P7wCRHZnFVdmgHu2nFwlWCI3WGc3TSWhUFGxTAUkGCbtgENBMJAEJsxgMLWzpEAACH5BAkKAAAALAAAAAAQABAAAAMyCLrc/jDKSatlQtScKdceCAjDII7HcQ4EMTCpyrCuUBjCYRgHVtqlAiB1YhiCnlsRkAAAOwAAAAAAAAAAAA=="></img> Loading... please wait.');
                    } else if (path.length == 1) {
                        if (path[0] in data.page && path[0] != "meta") show(data.page[path[0]]); else show(data.page.missing);
                    } else if (path[0] == data.meta.searchPath) {
                        var query = path.slice(1).join("/"), results;
                        console.log("[DEBUG] query: " + query);
                        if (query.charAt(0) == "/") {
                            results = getKeys(data.lexicon).filter(/./.test.bind(new RegExp(query.substring(1, query.length - 1)))).sort();
                        } else results = searchCache.get(query)
                            .sort(function (a, b) { return (a[0] == b[0]) ? ((a[1] == b[1]) ? 0 : ((a[1] < b[1]) ? -1 : 1)) : ((a.score > b.score) ? -1 : 1); })
                            .map(function (e) { return e[1] }).slice(0, data.meta.numresults);
                        if (results.length == 0) {
                            show(data.page.search.format(query, data.meta.noresults));
                        } else show(data.page.search.format(query, results.map(function (e) { return "1. [" + htmlEnt(e) + "](#/" + data.meta.lexicon + "/" + encodeURIComponent(e) + ")" }).join("\n\n")));
                    } else if (path[0] == data.meta.lexicon) {
                        var word = path.slice(1).join("/");
                        if (word in data.lexicon) {
                            if (data.lexicon[word].hasOwnProperty("redirect"))
                                location.hash = data.lexicon[word].redirect;
                            else show(renderWord(word));
                        } else show(data.page.missing);
                    } else {
                        var cur = data, found = false;
                        for (var c = 0; c < path.length; c++) {
                            if (path[c] in cur) {
                                if (typeof cur[path[c]] == 'object') {
                                    cur = cur[path[c]];
                                } else if (typeof cur[path[c]] == 'string') {
                                    show(cur[path[c]]);
                                    found = true;
                                    break;
                                } else break;
                            } else break;
                        }
                        if (!found) show(data.page.missing);
                    }
                }

                fetch(loc)
                    .then(res => res.json())
                    .then(more => {
                        data = more;
                        document.title = data.meta.name || 'Lexicon';
                        document.getElementById("title").innerHTML = document.title;
                        document.getElementById("search").setAttribute("placeholder", data.meta.search || 'search');
                        document.getElementById("scon").innerHTML = md(data.meta.sidebar || '');

                        const style = document.createElement("style");
                        style.innerHTML = data.meta.style;
                        document.head.appendChild(style);

                        void function load(iteration) {
                            if (iteration == data.meta.further.length) {
                                searchCache = new FuzzySet(getKeys(data.lexicon), true, 1, 4);
                                if (window.location.hash == "") window.location.hash = "/main"; else window.onhashchange();
                                return;
                            }
                            fetch(data.meta.further[iteration])
                                .then(res => res.json())
                                .then(more => data = merge(data, more))
                                .then(_ => load(iteration + 1));
                        }(0);
                    });
            }
        }
    </script>
</head>

<body>
    <div id="sidebar">
        <span id="tocm" style="display:none">NAV</span>
        <h3 id="title">Lexicon</h3>
        <input id="search" type="text" placeholder="search"></input>
        <hr />
        <div id="scon"></div>
    </div>
    <div id="content">
        <img
            src="data:image/gif;base64,R0lGODlhEAAQAPIAAP///wAAAMLCwkJCQgAAAGJiYoKCgpKSkiH/C05FVFNDQVBFMi4wAwEAAAAh/hpDcmVhdGVkIHdpdGggYWpheGxvYWQuaW5mbwAh+QQJCgAAACwAAAAAEAAQAAADMwi63P4wyklrE2MIOggZnAdOmGYJRbExwroUmcG2LmDEwnHQLVsYOd2mBzkYDAdKa+dIAAAh+QQJCgAAACwAAAAAEAAQAAADNAi63P5OjCEgG4QMu7DmikRxQlFUYDEZIGBMRVsaqHwctXXf7WEYB4Ag1xjihkMZsiUkKhIAIfkECQoAAAAsAAAAABAAEAAAAzYIujIjK8pByJDMlFYvBoVjHA70GU7xSUJhmKtwHPAKzLO9HMaoKwJZ7Rf8AYPDDzKpZBqfvwQAIfkECQoAAAAsAAAAABAAEAAAAzMIumIlK8oyhpHsnFZfhYumCYUhDAQxRIdhHBGqRoKw0R8DYlJd8z0fMDgsGo/IpHI5TAAAIfkECQoAAAAsAAAAABAAEAAAAzIIunInK0rnZBTwGPNMgQwmdsNgXGJUlIWEuR5oWUIpz8pAEAMe6TwfwyYsGo/IpFKSAAAh+QQJCgAAACwAAAAAEAAQAAADMwi6IMKQORfjdOe82p4wGccc4CEuQradylesojEMBgsUc2G7sDX3lQGBMLAJibufbSlKAAAh+QQJCgAAACwAAAAAEAAQAAADMgi63P7wCRHZnFVdmgHu2nFwlWCI3WGc3TSWhUFGxTAUkGCbtgENBMJAEJsxgMLWzpEAACH5BAkKAAAALAAAAAAQABAAAAMyCLrc/jDKSatlQtScKdceCAjDII7HcQ4EMTCpyrCuUBjCYRgHVtqlAiB1YhiCnlsRkAAAOwAAAAAAAAAAAA=="></img>
        Loading... please wait.
    </div>
</body>

<script>
    /**
     * ATTENTION
     * Here is where you may supply custom type handlers for your lexicon.
     * This may be done by passing the desired type and a handler function.
     * Search for "renderWord.register(" in the source code for examples.
     *
     * `renderWord.register("type", function(entry, word, current_section){...})`
     *
     */
    /**
     * ATTENTION
     * ===
     *
     * Here is where you specify the path of your lexicon's JSON file. Change the text
     * inside the quotes to change the path. A path starting with / will be absolute,
     * as in, if this file is at http://example.com/some-path/lexicon.html, and the
     * path provided is /lexicon.json, then the full path is
     * http://example.com/lexicon.json. If there is no /, it is relative:
     * http://example.com/some-path/lexicon.json.
     *
     * In addition, there are two options that can be changed:
     *  - lexicon: the object in your json file where the lexicon is. This is used for searches.
     *  - useNav: true to use the collapsing sidebar, false to use the static sidebar
     */
    lexicon("resources/lexicon.json", false);
</script>

</html>
